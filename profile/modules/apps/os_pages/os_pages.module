<?php

/**
 * @file
 * Pages app.
 */

use Drupal\Component\Render\FormattableMarkup;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\node\Entity\Node;
use Drupal\block_visibility_groups\Entity\BlockVisibilityGroup;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Url;
use Drupal\Core\Link;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Entity\EntityForm;

/**
 * Implements hook_entity_insert().
 *
 * @throws \Drupal\Core\Entity\EntityStorageException
 */
function os_pages_entity_insert(EntityInterface $entity) {
  /** @var \Drupal\os_pages\VisibilityHelper $visibility_helper */
  $visibility_helper = \Drupal::service('os_pages.visibility_helper');

  if ($entity->getEntityTypeId() != 'node' || $entity->bundle() != 'page') {
    return;
  }

  /** @var \Drupal\Core\Path\AliasManagerInterface $alias_manager */
  $alias_manager = \Drupal::service('path.alias_manager');

  $layout_context_storage = \Drupal::entityTypeManager()->getStorage('layout_context');
  $layout_context_storage->create([
    'id' => "os_pages_page_{$entity->id()}",
    'label' => t('Page Layout For @label', ['@label' => $entity->label()]),
    'activationRules' => $alias_manager->getAliasByPath("/node/{$entity->id()}"),
    'weight' => 100,
  ])->save();

  /** @var \Drupal\os_pages\VisibilityStorageInterface $visibility_storage */
  $visibility_storage = \Drupal::service('os_pages.visibility_storage');

  // Create page visibility group.
  $visibility_storage->create([
    'id' => "os_pages_page_{$entity->id()}",
    'label' => t('OS Pages: Page @name', [
      '@name' => $entity->label(),
    ]),
    'status' => TRUE,
    'allow_other_conditions' => TRUE,
    'logic' => 'and',
  ], [
    [
      'id' => 'node_type',
      'bundles' => [
        $entity->bundle() => $entity->bundle(),
      ],
      'negate' => FALSE,
      'context_mapping' => [
        'node' => '@node.node_route_context:node',
      ],
    ],
    [
      'id' => 'request_path',
      'pages' => "/node/{$entity->id()}",
      'negate' => FALSE,
      'context_mapping' => [],
    ],
  ]);

  if (!$visibility_helper->isBookPage($entity)) {
    return;
  }

  /** @var \Drupal\node\NodeInterface $book */
  $book = Node::load($entity->book['bid']);

  $section_id = "os_pages_section_{$book->id()}";
  /** @var \Drupal\os_widgets\LayoutContextInterface $section_layout */
  $section_layout = $layout_context_storage->load($section_id);
  // No book section yet.
  if (!$section_layout) {
    if ($visibility_helper->isBookFirstPage($entity)) {
      $section_layout = $layout_context_storage->create([
        'id' => $section_id,
        'label' => t('Section Layout For @label', ['@label' => $book->label()]),
        'activationRules' => implode("\n", [
          $alias_manager->getAliasByPath("/node/{$book->id()}"),
          $alias_manager->getAliasByPath("/node/{$entity->id()}"),
        ]),
        'weight' => 50,
        'data' => [
          'book_navigation' => [
            'id' => 'book_navigation',
            'region' => 'sidebar_first',
            'weight' => 0,
          ],
        ],
      ]);
      $section_layout->save();
    }
  }
  else {
    $paths = $section_layout->getActivationRules();
    $paths = explode("\n", $paths);
    $paths[] = $alias_manager->getAliasByPath("/node/{$entity->id()}");
    $section_layout->setActivationRules(implode("\n", $paths));
    $section_layout->save();
  }

  /** @var \Drupal\block_visibility_groups\Entity\BlockVisibilityGroup|null $section_visibility_group */
  $section_visibility_group = BlockVisibilityGroup::load($section_id);

  // Create/update section visibility group.
  if (!$section_visibility_group) {
    if ($visibility_helper->isBookFirstPage($entity)) {

      $visibility_storage->create([
        'id' => "os_pages_section_{$book->id()}",
        'label' => t('OS Pages: Section @book_name', [
          '@book_name' => $book->label(),
        ]),
        'status' => TRUE,
        'allow_other_conditions' => TRUE,
        'logic' => 'and',
      ], [
        [
          'id' => 'node_type',
          'bundles' => [
            $entity->bundle() => $entity->bundle(),
          ],
          'negate' => FALSE,
          'context_mapping' => [
            'node' => '@node.node_route_context:node',
          ],
        ],
        [
          'id' => 'request_path',
          'pages' => "/node/{$book->id()}\n/node/{$entity->id()}",
          'negate' => FALSE,
          'context_mapping' => [],
        ],
      ]);
    }
  }
  else {
    // Update the path condition for section visibility group.
    // Making sure that it appears for the newly created page as well.
    /** @var array $conditions */
    $conditions = $section_visibility_group->getConditions()->getConfiguration();

    foreach ($conditions as $condition) {
      if ($condition['id'] === 'request_path') {
        /** @var string $condition_id */
        $condition_id = $condition['uuid'];
        /** @var string $pages */
        $pages = $condition['pages'];
      }
    }

    if (!isset($condition_id) && !isset($pages)) {
      return;
    }

    $section_visibility_group->removeCondition($condition_id);

    $section_visibility_group->addCondition([
      'id' => 'request_path',
      'pages' => "$pages\n/node/{$entity->id()}",
      'negate' => 0,
      'context_mapping' => [],
    ]);

    $section_visibility_group->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_prepare_form() for pre-setting the data required for creating sub-pages.
 *
 * This is an exact copy of `book_node_prepare_form`. It has wrapped everything
 * in an access check, which makes it impossible to create sub-pages by vsite
 * members.
 *
 * @see \book_node_prepare_form
 */
function os_pages_node_prepare_form(NodeInterface $node, $operation, FormStateInterface $form_state) {
  /** @var \Drupal\vsite\Plugin\VsiteContextManagerInterface $vsite_context_manager */
  $vsite_context_manager = \Drupal::service('vsite.context_manager');
  /** @var \Drupal\group\Entity\GroupInterface|null $active_vsite */
  $active_vsite = $vsite_context_manager->getActiveVsite();

  // Let the book module handle everything, if node is not meant to be created
  // for a vsite.
  if ($active_vsite && book_type_is_allowed($node->getType())) {
    /** @var \Drupal\book\BookManagerInterface $book_manager */
    $book_manager = \Drupal::service('book.manager');
    if (empty($node->book)) {
      $node->book = [];

      $query = \Drupal::request()->query;
      if ($node->isNew() && $query->get('parent') !== NULL && is_numeric($query->get('parent'))) {
        // Handle "Add child page" links:
        $parent = $book_manager->loadBookLink($query->get('parent'), TRUE);

        if ($parent && $parent['access']) {
          $node->book['bid'] = $parent['bid'];
          $node->book['pid'] = $parent['nid'];
        }
      }
      // Set defaults.
      $node_ref = !$node->isNew() ? $node->id() : 'new';
      $node->book += $book_manager->getLinkDefaults($node_ref);
    }
    elseif (isset($node->book['bid']) && !isset($node->book['original_bid'])) {
      $node->book['original_bid'] = $node->book['bid'];
    }

    // Find the depth limit for the parent select.
    if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {
      $node->book['parent_depth_limit'] = $book_manager->getParentDepthLimit($node->book);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Handling book attributes while editing page.
 */
function os_pages_form_node_page_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  os_pages_node_page_alter($form, $form_state);
  os_pages_meta_tags_alter($form, $form_state);
}

/**
 * Implements hook_form_alter().
 *
 * Manage book outline meta tag form element.
 */
function os_pages_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();
  if ($form_object instanceof EntityForm) {
    _os_pages_remove_book_outline_form_element($form, $form_object->getEntity());
  }
}

/**
 * Remove book outline form element from not allowed node forms.
 *
 * @param array $form
 *   Form array.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Form state entity.
 */
function _os_pages_remove_book_outline_form_element(array &$form, EntityInterface $entity) {
  if ($entity->getEntityTypeId() != 'node' || !isset($form['book'])) {
    return;
  }
  if (book_type_is_allowed($entity->bundle())) {
    return;
  }
  $form['book']['#access'] = FALSE;
  $form['book']['bid']['#access'] = FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Handling book attributes while creating page.
 */
function os_pages_form_node_page_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  os_pages_node_page_alter($form, $form_state);
  os_pages_meta_tags_alter($form, $form_state);
}

/**
 * Custom function to handle book feature for pages.
 *
 * With this, vsite users can manage pages & sub-pages for books.
 *
 * Much of the code is similar to `book_form_node_form_alter`. It has wrapped
 * everything inside an access check, that makes it impossible to create a
 * sub-page by vsite members.
 *
 * @see \book_form_node_form_alter
 */
function os_pages_node_page_alter(array &$form, FormStateInterface $form_state) {
  $disabled = FALSE;
  $checked = FALSE;
  /** @var \Drupal\vsite\Plugin\VsiteContextManagerInterface $vsite_context_manager */
  $vsite_context_manager = \Drupal::service('vsite.context_manager');
  /** @var \Drupal\group\Entity\GroupInterface|null $active_vsite */
  $active_vsite = $vsite_context_manager->getActiveVsite();

  // Let the book module handle everything, if node is not meant to be created
  // for a vsite.
  if (!$active_vsite) {
    return;
  }

  /** @var \Drupal\Core\Session\AccountInterface $current_user */
  $current_user = \Drupal::currentUser();
  /** @var \Drupal\book\BookManagerInterface $book_manager */
  $book_manager = \Drupal::service('book.manager');
  /** @var \Drupal\node\NodeInterface $node */
  $node = $form_state->getFormObject()->getEntity();
  $is_already_in_page_hierarchy = !($node->isNew() && !empty($node->book['pid']));

  $access = ($active_vsite->hasPermission('add content to books', $current_user) && book_type_is_allowed($node->getType()));

  $form = $book_manager->addFormElements($form, $form_state, $node, $current_user, $is_already_in_page_hierarchy);
  // Override the accesses given inside book module.
  $form['book']['#access'] = $access;
  $form['book']['bid']['#access'] = $access;

  // Here, set NID value to new if a new book is to be created.
  $nid = !$node->isNew() ? $node->id() : 'new';

  if ($nid === 'new' && $active_vsite->hasPermission('create new books', $current_user)) {
    $form['book']['bid']['#access'] = FALSE;
    $form['book']['pid']['#access'] = FALSE;
    unset($form['book']['weight']);
    $query = \Drupal::request()->query;

    // The node can become a new book, if it is not one already.
    if ($query->get('parent')) {
      $disabled = TRUE;
      $checked = TRUE;
      $parent = $query->get('parent');
    }

    $form['book']['checkbox'] = [
      '#type' => 'checkbox',
      '#title' => t('Allow this page to be part of a book'),
      '#default_value' => $checked,
      '#ajax' => [
        'callback' => 'os_pages_book_custom_form_update',
      ],
      '#attributes' => ['disabled' => $disabled],
    ];
  }

  // Setting bid as parent or 'new' if its a new book.
  if (isset($parent)) {
    $parent_node = Node::load($parent);
    $bid = ($parent_node->book['pid'] != 0) ? $parent_node->book['pid'] : $parent_node->book['bid'];
    $pid = $parent;
    $node->book['bid'] = $bid;
    $node->book['pid'] = $pid;
  }
  else {
    $bid = $nid;
    $pid = 0;
  }

  // Get checkbox value.
  $new = $form_state->getTriggeringElement();
  // Add book id if checkbox is triggered and selected.
  if ($new['#attributes']['data-drupal-selector'] == 'edit-book-checkbox' && $new['#value'] == 1) {
    $form['book']['bid']['#value'] = $bid;
    $form['book']['pid']['#value'] = $pid;
  }

  // The "js-hide" class hides submit button when Javascript is enabled.
  $form['book']['pick-book'] = [
    '#type' => 'submit',
    '#value' => t('Change book (update list of parents)'),
    '#submit' => ['book_pick_book_nojs_submit'],
    '#weight' => 20,
    '#attributes' => [
      'class' => [
        'js-hide',
      ],
    ],
  ];
  $form['#entity_builders'][] = 'book_node_builder';
}

/**
 * Performs ajax action on checkbox.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function os_pages_book_custom_form_update(array $form, FormStateInterface $form_state) {
  return $form['book']['bid'];
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function os_pages_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node instanceof NodeInterface && $node->bundle() !== 'page' && isset($data['tabs'][0])) {
    foreach ($data['tabs'][0] as $task => $tab) {
      if (strpos($task, 'book_outline') !== FALSE) {
        unset($data['tabs'][0][$task]);
      }
    }
  }

  // Hide Outline tab if the node is just a page and if it's not a book.
  if ($node instanceof NodeInterface && $node->bundle() == 'page' && empty($node->book)) {
    unset($data['tabs'][0]['entity.node.book_outline_form']);
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Force os_pages to be behind pathauto so we can read aliases.
 */
function os_pages_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_insert') {
    $group = $implementations['os_pages'];
    unset($implementations['os_pages']);
    $implementations['os_pages'] = $group;
  }
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function os_pages_contextual_links_view_alter(&$element, $items) {
  if (isset($element['#contextual_links']['node'])) {
    $nid = $element['#contextual_links']['node']['route_parameters']['node'];
    $entity = Node::load($nid);

    // Checking content type page.
    if ($entity->bundle() == 'page') {

      // Checking current page is a child of another page or has a child.
      if ($entity->book['has_children'] || $entity->book['pid']) {
        $element['#links']['outline'] = [
          'title' => t('Outline'),
          'url' => Url::fromRoute('entity.node.book_outline_form', [
            'node' => $entity->id(),
          ]),
        ];
      }

      // Checking node has book id.
      if (!empty($entity->book['bid'])) {
        $element['#links']['add_subpage'] = [
          'title' => t('Add Subpage'),
          'url' => Url::fromRoute('node.add', [
            'node_type' => 'page',
            'parent' => $entity->id(),
          ]),
        ];
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_view_alter().
 *
 * Attaching contextualChanges library to pages (book)
 * to handle changes in contextual links for book pages.
 */
function os_pages_node_view_alter(array &$build, NodeInterface $entity, EntityViewDisplayInterface $display) {
  if ($entity->bundle() == 'page' && !empty($entity->book['bid'])) {
    $build['#attached']['library'][] = 'os_pages/contextualChanges';
  }
}

/**
 * Implements hook_theme().
 */
function os_pages_theme() {
  return [
    'page_export_html' => [
      'variables' => [
        'content' => NULL,
      ],
    ],
    'book_export_html' => [
      'template' => 'book-export-html',
      'base hook' => 'book',
    ],
  ];
}

/**
 * Prepares variables for page export templates.
 *
 * Template: page-export-html.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - title: The title of the page.
 *   - content: Page content.
 */
function template_preprocess_page_export_html(array &$variables) {
  global $base_url;
  $language_interface = \Drupal::languageManager()->getCurrentLanguage();
  $variables['base_url'] = $base_url;
  $variables['#attached']['library'][] = 'os_pages/pageExport';

  // HTML element attributes.
  $attributes = [];
  $attributes['lang'] = $language_interface->getId();
  $attributes['dir'] = $language_interface->getDirection();
  $variables['html_attributes'] = new Attribute($attributes);
  $variables['css_path'] = drupal_get_path('module', 'os_pages') . '/css';
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Adding customized css for book export page.
 */
function os_pages_preprocess_book_export_html(&$variables) {
  $variables['css_path'] = drupal_get_path('module', 'os_pages') . '/css';
}

/**
 * Implements hook_node_links_alter().
 *
 * Setting print-friendly page export link for Page.
 */
function os_pages_node_links_alter(array &$links, NodeInterface $node, array &$context) {
  if ($node->bundle() == "page" && !empty($node->book)) {
    unset($links['book']['#links']['book_add_child']);
  }

  if ($node->bundle() == "page" && $context['view_mode'] == 'full' && node_is_page($node) && empty($node->book)) {
    $book_links['book_printer'] = [
      'title' => t('Printer-friendly version'),
      'url' => Url::fromRoute('os_pages.export', [
        'node' => $node->id(),
      ]),
      'attributes' => ['title' => t('Show a printer-friendly version of this page.')],
    ];
  }

  if (!empty($book_links)) {
    $links['book'] = [
      '#theme' => 'links__node__book',
      '#links' => $book_links,
      '#attributes' => ['class' => ['links', 'inline']],
    ];
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function os_pages_form_node_page_book_outline_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\vsite\Plugin\VsiteContextManagerInterface $vsite_context_manager */
  $vsite_context_manager = \Drupal::service('vsite.context_manager');
  /** @var \Drupal\group\Entity\GroupInterface|null $active_vsite */
  $active_vsite = $vsite_context_manager->getActiveVsite();
  if ($active_vsite) {
    foreach ($active_vsite->getContent('group_node:page') as $group_content) {
      $vsite_nids[] = $group_content->entity_id->target_id;
    }

    $current_nid = $form['book']['nid']['#value'];
    $book_options = $form['book']['bid']['#options'];
    // Removing form options if page is not from this vsite.
    foreach ($book_options as $key => $value) {
      if (!in_array($key, $vsite_nids)) {
        unset($book_options[$key]);
      }
    }
    $form['book']['bid']['#options'] = $book_options;
    $link = Link::fromTextAndUrl(t('Add other book pages to this outline'), Url::fromRoute('os_pages.add_other_books', ['node' => $current_nid]));
    $link = new FormattableMarkup($link->toString(), []);
    $form['book']['add_book_pages'] = [
      '#markup' => $link,
      '#weight' => -10,
    ];
  }
}

/**
 * Custom function to handle meta tags for pages.
 */
function os_pages_meta_tags_alter(array &$form, FormStateInterface $form_state) {
  $form['field_meta_tags']['widget']['0']['#title'] = t('Search Engine Optimization (SEO)');
  $form['field_meta_tags']['widget']['0']['basic']['title']['#access'] = FALSE;
  $form['field_meta_tags']['widget']['0']['basic']['abstract']['#access'] = FALSE;
  $form['field_meta_tags']['widget']['0']['basic']['keywords']['#access'] = FALSE;
  $form['field_meta_tags']['widget']['0']['basic']['vsite_privacy_robots']['#access'] = FALSE;
  $form['field_meta_tags']['widget']['0']['basic']['#description'] = FALSE;
  $form['field_meta_tags']['widget']['0']['basic']['description']['#title'] = t('Meta Description');
  $form['field_meta_tags']['widget']['0']['basic']['description']['#description'] = t('Best if 150 characters or less. Used as a meta description tag and instead of trimmed body in certain lists.');
  unset($form['field_meta_tags']['widget']['0']['intro_text']['#markup']);
  unset($form['field_meta_tags']['widget']['0']['tokens']);
  unset($form['field_meta_tags']['widget']['0']['basic']['#type']);
}
